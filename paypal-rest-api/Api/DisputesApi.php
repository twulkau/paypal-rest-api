<?php
/**
 * DisputesApi
 * PHP version 5
 *
 * @category Class
 * @package  PayPal\RestApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PayPal APIs
 *
 * # Getting Started  ## Step 1: Fork the collection using Run in Postman  [](https://god.gw.postman.com/run-collection/19024122-92a85d0e-51e7-47da-9f83-c45dcb1cdf24?action=collection/fork&collection-url=entityId=19024122-92a85d0e-51e7-47da-9f83-c45dcb1cdf24&entityType=collection&workspaceId=345300e6-346e-42e0-aed1-53717919aef0#?env[PayPal%20Override%20Env]=W3sia2V5IjoiUGxlYXNlIE5vdGUgLS0+IiwidmFsdWUiOiI8IFBheVBhbCBQdWJsaWMgQ29sbGVjdGlvbiBjb21lcyB3aXRoIGRlZmF1bHQgcHVibGljIHNldCBvZiBjcmVkZW50aWFscyBzdG9yZWQgYXQgdGhlIENvbGxlY3Rpb24gbGV2ZWwuIFxuVGhpcyBlbnZpcm9ubWVudCBvdmVycmlkZXMgdGhvc2UgZGVmYXVsdCB2YXJpYWJsZXMuIFlvdSBtYXkgYnJpbmcgeW91ciBvd24gY3JlZGVudGlhbHMgZnJvbSBQYXlQYWwgRGV2ZWxvcGVyIERhc2hib2FyZCBhbmQgcGFzdGUgdGhlbSBoZXJlLiBEbyBub3QgZm9yZ290IHRvIGVuYWJsZSB0aGUgdmFpYWJsZSBieSBjaGVja2luZyB0aGUgYm94IGFuZCBoaXQgXCJTYXZlXCIgYmVmb3JlIGludm9raW5nIHRoZSBQYXlQYWwgQVBJcy4gPiIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoiY2xpZW50X2lkIiwidmFsdWUiOiI8IGNvcHkgY3JlZGVudGlhbHMgZnJvbSB5b3VyIGRldmVsb3Blci5wYXlwYWwuY29tIGFuZCBwYXN0ZSB0aGVtIGhlcmUgPiIsImVuYWJsZWQiOmZhbHNlfSx7ImtleSI6ImNsaWVudF9zZWNyZXQiLCJ2YWx1ZSI6IjwgY29weSBjcmVkZW50aWFscyBmcm9tIHlvdXIgZGV2ZWxvcGVyLnBheXBhbC5jb20gYW5kIHBhc3RlIHRoZW0gaGVyZSA+IiwiZW5hYmxlZCI6ZmFsc2V9XQ==)  [![](https://run.pstmn.io/button.svg)](https://god.gw.postman.com/run-collection/19024122-92a85d0e-51e7-47da-9f83-c45dcb1cdf24?action=collection/fork&collection-url=entityId=19024122-92a85d0e-51e7-47da-9f83-c45dcb1cdf24&entityType=collection&workspaceId=345300e6-346e-42e0-aed1-53717919aef0#?env[PayPal%20Override%20Env]=W3sia2V5IjoiUGxlYXNlIE5vdGUgLS0+IiwidmFsdWUiOiI8IFBheVBhbCBQdWJsaWMgQ29sbGVjdGlvbiBjb21lcyB3aXRoIGRlZmF1bHQgcHVibGljIHNldCBvZiBjcmVkZW50aWFscyBzdG9yZWQgYXQgdGhlIENvbGxlY3Rpb24gbGV2ZWwuIFxuVGhpcyBlbnZpcm9ubWVudCBvdmVycmlkZXMgdGhvc2UgZGVmYXVsdCB2YXJpYWJsZXMuIFlvdSBtYXkgYnJpbmcgeW91ciBvd24gY3JlZGVudGlhbHMgZnJvbSBQYXlQYWwgRGV2ZWxvcGVyIERhc2hib2FyZCBhbmQgcGFzdGUgdGhlbSBoZXJlLiBEbyBub3QgZm9yZ290IHRvIGVuYWJsZSB0aGUgdmFpYWJsZSBieSBjaGVja2luZyB0aGUgYm94IGFuZCBoaXQgXCJTYXZlXCIgYmVmb3JlIGludm9raW5nIHRoZSBQYXlQYWwgQVBJcy4gPiIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoiY2xpZW50X2lkIiwidmFsdWUiOiI8IGNvcHkgY3JlZGVudGlhbHMgZnJvbSB5b3VyIGRldmVsb3Blci5wYXlwYWwuY29tIGFuZCBwYXN0ZSB0aGVtIGhlcmUgPiIsImVuYWJsZWQiOmZhbHNlfSx7ImtleSI6ImNsaWVudF9zZWNyZXQiLCJ2YWx1ZSI6IjwgY29weSBjcmVkZW50aWFscyBmcm9tIHlvdXIgZGV2ZWxvcGVyLnBheXBhbC5jb20gYW5kIHBhc3RlIHRoZW0gaGVyZSA+IiwiZW5hYmxlZCI6ZmFsc2V9XQ==)  ## Step 2: Get your access token  An access token is automatically generated using a default `client_id` and `secret`. PayPal recommends using your own `client_id` and `secret` from the [Developer Dashboard](https://www.paypal.com/signin?intent=developer&returnUri=https%3A%2F%2Fdeveloper.paypal.com%2Fdeveloper%2Fapplication) by entering the values under the **Variables** tab. A pre-request script will generate and manage the `access_token` automatically.  > **Note:** Your developer account `client_id` and `secret` may have a different scope than the default `client_id` and `secret`.  ## Step 3: Make your first API call  PayPal recommends starting with the Orders API. These steps will use the Orders API to create an order and capture payment using [sandbox accounts](https://developer.paypal.com/developer/accounts) linked to your Developer Dashboard account.  To create an order:  1. In your workspace, navigate to your fork of the PayPal collection. 1. Select **Orders > Create Order**. 1. Select the **Send** button to create the order. On a successful call, the API returns a 201 order created response code. 1. In the response, find the **approve** link. 1. Open the **approve** link in a browser. 1. Log in with your Developer Dashboard Sandbox Personal Account credentials. You can find those credentials by logging into the Developer Dashboard and selecting **Sandbox > Account** 1. Select the **Continue** button. Payment has now been made.  To capture payment:  1. In the response of the order you created, find the `order_id`. 1. In the **Variables** tab, enter the `order_id` number. 1. Select **Orders > Capture payment for order**. 1. Select **Send**. On a successful call, the API returns a 201 order created response code.  Your order has been created and payment has been captured. You can verify the transaction in both the sandbox personal account and the sandbox business account.  ![Buyer Payment Verification](https://www.paypalobjects.com/devdoc/transaction-details-buyer.png) ![Seller Payment Verification](https://www.paypalobjects.com/devdoc/transaction-details-seller.png)
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.32
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace PayPal\RestApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use PayPal\RestApi\ApiException;
use PayPal\RestApi\Configuration;
use PayPal\RestApi\HeaderSelector;
use PayPal\RestApi\ObjectSerializer;

/**
 * DisputesApi Class Doc Comment
 *
 * @category Class
 * @package  PayPal\RestApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DisputesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation acceptClaim
     *
     * Accept claim
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 72 hours. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body13 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \PayPal\RestApi\Model\InlineResponse2009
     */
    public function acceptClaim($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        list($response) = $this->acceptClaimWithHttpInfo($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);
        return $response;
    }

    /**
     * Operation acceptClaimWithHttpInfo
     *
     * Accept claim
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 72 hours. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body13 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \PayPal\RestApi\Model\InlineResponse2009, HTTP status code, HTTP response headers (array of strings)
     */
    public function acceptClaimWithHttpInfo($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse2009';
        $request = $this->acceptClaimRequest($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse2009',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4006',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4033',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40420',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse42213',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation acceptClaimAsync
     *
     * Accept claim
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 72 hours. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body13 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptClaimAsync($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        return $this->acceptClaimAsyncWithHttpInfo($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation acceptClaimAsyncWithHttpInfo
     *
     * Accept claim
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 72 hours. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body13 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptClaimAsyncWithHttpInfo($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse2009';
        $request = $this->acceptClaimRequest($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'acceptClaim'
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 72 hours. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body13 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function acceptClaimRequest($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling acceptClaim'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/accept-claim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($pay_pal_request_id !== null) {
            $headerParams['PayPal-Request-Id'] = ObjectSerializer::toHeaderValue($pay_pal_request_id);
        }
        // header params
        if ($pay_pal_client_metadata_id !== null) {
            $headerParams['PayPal-Client-Metadata-Id'] = ObjectSerializer::toHeaderValue($pay_pal_client_metadata_id);
        }
        // header params
        if ($pay_pal_partner_attribution_id !== null) {
            $headerParams['PayPal-Partner-Attribution-Id'] = ObjectSerializer::toHeaderValue($pay_pal_partner_attribution_id);
        }
        // header params
        if ($pay_pal_auth_assertion !== null) {
            $headerParams['PayPal-Auth-Assertion'] = ObjectSerializer::toHeaderValue($pay_pal_auth_assertion);
        }
        // header params
        if ($prefer !== null) {
            $headerParams['Prefer'] = ObjectSerializer::toHeaderValue($prefer);
        }
        // header params
        if ($prefer2 !== null) {
            $headerParams['Prefer'] = ObjectSerializer::toHeaderValue($prefer2);
        }

        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation acceptOfferToResolveDispute
     *
     * Accept offer to resolve dispute
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body14 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function acceptOfferToResolveDispute($dispute_id, $body = null)
    {
        $this->acceptOfferToResolveDisputeWithHttpInfo($dispute_id, $body);
    }

    /**
     * Operation acceptOfferToResolveDisputeWithHttpInfo
     *
     * Accept offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body14 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function acceptOfferToResolveDisputeWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->acceptOfferToResolveDisputeRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4034',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40421',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation acceptOfferToResolveDisputeAsync
     *
     * Accept offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body14 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptOfferToResolveDisputeAsync($dispute_id, $body = null)
    {
        return $this->acceptOfferToResolveDisputeAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation acceptOfferToResolveDisputeAsyncWithHttpInfo
     *
     * Accept offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body14 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptOfferToResolveDisputeAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->acceptOfferToResolveDisputeRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'acceptOfferToResolveDispute'
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body14 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function acceptOfferToResolveDisputeRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling acceptOfferToResolveDispute'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/accept-offer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation acknowledgeReturnedItem
     *
     * Acknowledge returned item
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body15 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function acknowledgeReturnedItem($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        $this->acknowledgeReturnedItemWithHttpInfo($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);
    }

    /**
     * Operation acknowledgeReturnedItemWithHttpInfo
     *
     * Acknowledge returned item
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body15 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function acknowledgeReturnedItemWithHttpInfo($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        $returnType = '';
        $request = $this->acknowledgeReturnedItemRequest($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4035',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40422',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation acknowledgeReturnedItemAsync
     *
     * Acknowledge returned item
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body15 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acknowledgeReturnedItemAsync($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        return $this->acknowledgeReturnedItemAsyncWithHttpInfo($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation acknowledgeReturnedItemAsyncWithHttpInfo
     *
     * Acknowledge returned item
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body15 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acknowledgeReturnedItemAsyncWithHttpInfo($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        $returnType = '';
        $request = $this->acknowledgeReturnedItemRequest($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'acknowledgeReturnedItem'
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body15 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function acknowledgeReturnedItemRequest($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling acknowledgeReturnedItem'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/acknowledge-return-item';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($pay_pal_request_id !== null) {
            $headerParams['PayPal-Request-Id'] = ObjectSerializer::toHeaderValue($pay_pal_request_id);
        }
        // header params
        if ($pay_pal_client_metadata_id !== null) {
            $headerParams['PayPal-Client-Metadata-Id'] = ObjectSerializer::toHeaderValue($pay_pal_client_metadata_id);
        }
        // header params
        if ($pay_pal_partner_attribution_id !== null) {
            $headerParams['PayPal-Partner-Attribution-Id'] = ObjectSerializer::toHeaderValue($pay_pal_partner_attribution_id);
        }
        // header params
        if ($pay_pal_auth_assertion !== null) {
            $headerParams['PayPal-Auth-Assertion'] = ObjectSerializer::toHeaderValue($pay_pal_auth_assertion);
        }
        // header params
        if ($prefer !== null) {
            $headerParams['Prefer'] = ObjectSerializer::toHeaderValue($prefer);
        }
        // header params
        if ($prefer2 !== null) {
            $headerParams['Prefer'] = ObjectSerializer::toHeaderValue($prefer2);
        }

        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appealDispute
     *
     * Appeal dispute
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  object $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appealDispute($dispute_id, $body = null)
    {
        $this->appealDisputeWithHttpInfo($dispute_id, $body);
    }

    /**
     * Operation appealDisputeWithHttpInfo
     *
     * Appeal dispute
     *
     * @param  string $dispute_id (required)
     * @param  object $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appealDisputeWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->appealDisputeRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appealDisputeAsync
     *
     * Appeal dispute
     *
     * @param  string $dispute_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appealDisputeAsync($dispute_id, $body = null)
    {
        return $this->appealDisputeAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appealDisputeAsyncWithHttpInfo
     *
     * Appeal dispute
     *
     * @param  string $dispute_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appealDisputeAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->appealDisputeRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appealDispute'
     *
     * @param  string $dispute_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appealDisputeRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling appealDispute'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/appeal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation denyOfferToResolveDispute
     *
     * Deny offer to resolve dispute
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body17 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function denyOfferToResolveDispute($dispute_id, $body = null)
    {
        $this->denyOfferToResolveDisputeWithHttpInfo($dispute_id, $body);
    }

    /**
     * Operation denyOfferToResolveDisputeWithHttpInfo
     *
     * Deny offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body17 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function denyOfferToResolveDisputeWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->denyOfferToResolveDisputeRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4037',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40424',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation denyOfferToResolveDisputeAsync
     *
     * Deny offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body17 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function denyOfferToResolveDisputeAsync($dispute_id, $body = null)
    {
        return $this->denyOfferToResolveDisputeAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation denyOfferToResolveDisputeAsyncWithHttpInfo
     *
     * Deny offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body17 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function denyOfferToResolveDisputeAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->denyOfferToResolveDisputeRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'denyOfferToResolveDispute'
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body17 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function denyOfferToResolveDisputeRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling denyOfferToResolveDispute'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/deny-offer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation escalateDisputeToClaim
     *
     * Escalate dispute to claim
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body18 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \PayPal\RestApi\Model\InlineResponse20010
     */
    public function escalateDisputeToClaim($dispute_id, $body = null)
    {
        list($response) = $this->escalateDisputeToClaimWithHttpInfo($dispute_id, $body);
        return $response;
    }

    /**
     * Operation escalateDisputeToClaimWithHttpInfo
     *
     * Escalate dispute to claim
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body18 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \PayPal\RestApi\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function escalateDisputeToClaimWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20010';
        $request = $this->escalateDisputeToClaimRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4038',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40425',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse42214',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation escalateDisputeToClaimAsync
     *
     * Escalate dispute to claim
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body18 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function escalateDisputeToClaimAsync($dispute_id, $body = null)
    {
        return $this->escalateDisputeToClaimAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation escalateDisputeToClaimAsyncWithHttpInfo
     *
     * Escalate dispute to claim
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body18 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function escalateDisputeToClaimAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20010';
        $request = $this->escalateDisputeToClaimRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'escalateDisputeToClaim'
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body18 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function escalateDisputeToClaimRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling escalateDisputeToClaim'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/escalate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDisputes
     *
     * List disputes
     *
     * @param  string $start_time Filters the disputes in the response by a creation date and time. The start time must be within the last 180 days. Value is in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameters. (optional)
     * @param  string $disputed_transaction_id Filters the disputes in the response by a transaction, by ID.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameter. (optional)
     * @param  string $page_size Limits the number of disputes in the response to this value. (optional)
     * @param  string $next_page_token The token that describes the next page of results to fetch. The &lt;a href&#x3D;\&quot;https://developer.paypal.com/api/customer-disputes/v1/#disputes_list\&quot;&gt;list disputes&lt;/a&gt; call returns this token in the HATEOAS links in the response. (optional)
     * @param  string $dispute_state Filters the disputes in the response by a state. Separate multiple values with a comma (&#x60;,&#x60;). When you specify more than one dispute_state, the response lists disputes that belong to any of the specified dispute_state. (optional)
     * @param  string $update_time_before The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_before must be within the last 180 days and the default is the current time. (optional)
     * @param  string $update_time_after The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_after must be within the last 180 days and the default is the maximum time (180 days) supported. (optional)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \PayPal\RestApi\Model\InlineResponse2007
     */
    public function listDisputes($start_time = null, $disputed_transaction_id = null, $page_size = null, $next_page_token = null, $dispute_state = null, $update_time_before = null, $update_time_after = null, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null)
    {
        list($response) = $this->listDisputesWithHttpInfo($start_time, $disputed_transaction_id, $page_size, $next_page_token, $dispute_state, $update_time_before, $update_time_after, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2);
        return $response;
    }

    /**
     * Operation listDisputesWithHttpInfo
     *
     * List disputes
     *
     * @param  string $start_time Filters the disputes in the response by a creation date and time. The start time must be within the last 180 days. Value is in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameters. (optional)
     * @param  string $disputed_transaction_id Filters the disputes in the response by a transaction, by ID.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameter. (optional)
     * @param  string $page_size Limits the number of disputes in the response to this value. (optional)
     * @param  string $next_page_token The token that describes the next page of results to fetch. The &lt;a href&#x3D;\&quot;https://developer.paypal.com/api/customer-disputes/v1/#disputes_list\&quot;&gt;list disputes&lt;/a&gt; call returns this token in the HATEOAS links in the response. (optional)
     * @param  string $dispute_state Filters the disputes in the response by a state. Separate multiple values with a comma (&#x60;,&#x60;). When you specify more than one dispute_state, the response lists disputes that belong to any of the specified dispute_state. (optional)
     * @param  string $update_time_before The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_before must be within the last 180 days and the default is the current time. (optional)
     * @param  string $update_time_after The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_after must be within the last 180 days and the default is the maximum time (180 days) supported. (optional)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \PayPal\RestApi\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDisputesWithHttpInfo($start_time = null, $disputed_transaction_id = null, $page_size = null, $next_page_token = null, $dispute_state = null, $update_time_before = null, $update_time_after = null, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse2007';
        $request = $this->listDisputesRequest($start_time, $disputed_transaction_id, $page_size, $next_page_token, $dispute_state, $update_time_before, $update_time_after, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse403',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listDisputesAsync
     *
     * List disputes
     *
     * @param  string $start_time Filters the disputes in the response by a creation date and time. The start time must be within the last 180 days. Value is in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameters. (optional)
     * @param  string $disputed_transaction_id Filters the disputes in the response by a transaction, by ID.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameter. (optional)
     * @param  string $page_size Limits the number of disputes in the response to this value. (optional)
     * @param  string $next_page_token The token that describes the next page of results to fetch. The &lt;a href&#x3D;\&quot;https://developer.paypal.com/api/customer-disputes/v1/#disputes_list\&quot;&gt;list disputes&lt;/a&gt; call returns this token in the HATEOAS links in the response. (optional)
     * @param  string $dispute_state Filters the disputes in the response by a state. Separate multiple values with a comma (&#x60;,&#x60;). When you specify more than one dispute_state, the response lists disputes that belong to any of the specified dispute_state. (optional)
     * @param  string $update_time_before The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_before must be within the last 180 days and the default is the current time. (optional)
     * @param  string $update_time_after The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_after must be within the last 180 days and the default is the maximum time (180 days) supported. (optional)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDisputesAsync($start_time = null, $disputed_transaction_id = null, $page_size = null, $next_page_token = null, $dispute_state = null, $update_time_before = null, $update_time_after = null, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null)
    {
        return $this->listDisputesAsyncWithHttpInfo($start_time, $disputed_transaction_id, $page_size, $next_page_token, $dispute_state, $update_time_before, $update_time_after, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDisputesAsyncWithHttpInfo
     *
     * List disputes
     *
     * @param  string $start_time Filters the disputes in the response by a creation date and time. The start time must be within the last 180 days. Value is in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameters. (optional)
     * @param  string $disputed_transaction_id Filters the disputes in the response by a transaction, by ID.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameter. (optional)
     * @param  string $page_size Limits the number of disputes in the response to this value. (optional)
     * @param  string $next_page_token The token that describes the next page of results to fetch. The &lt;a href&#x3D;\&quot;https://developer.paypal.com/api/customer-disputes/v1/#disputes_list\&quot;&gt;list disputes&lt;/a&gt; call returns this token in the HATEOAS links in the response. (optional)
     * @param  string $dispute_state Filters the disputes in the response by a state. Separate multiple values with a comma (&#x60;,&#x60;). When you specify more than one dispute_state, the response lists disputes that belong to any of the specified dispute_state. (optional)
     * @param  string $update_time_before The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_before must be within the last 180 days and the default is the current time. (optional)
     * @param  string $update_time_after The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_after must be within the last 180 days and the default is the maximum time (180 days) supported. (optional)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDisputesAsyncWithHttpInfo($start_time = null, $disputed_transaction_id = null, $page_size = null, $next_page_token = null, $dispute_state = null, $update_time_before = null, $update_time_after = null, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse2007';
        $request = $this->listDisputesRequest($start_time, $disputed_transaction_id, $page_size, $next_page_token, $dispute_state, $update_time_before, $update_time_after, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDisputes'
     *
     * @param  string $start_time Filters the disputes in the response by a creation date and time. The start time must be within the last 180 days. Value is in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameters. (optional)
     * @param  string $disputed_transaction_id Filters the disputes in the response by a transaction, by ID.&lt;br/&gt;&lt;br/&gt;You can specify either but not both the &#x60;start_time&#x60; and &#x60;disputed_transaction_id&#x60; query parameter. (optional)
     * @param  string $page_size Limits the number of disputes in the response to this value. (optional)
     * @param  string $next_page_token The token that describes the next page of results to fetch. The &lt;a href&#x3D;\&quot;https://developer.paypal.com/api/customer-disputes/v1/#disputes_list\&quot;&gt;list disputes&lt;/a&gt; call returns this token in the HATEOAS links in the response. (optional)
     * @param  string $dispute_state Filters the disputes in the response by a state. Separate multiple values with a comma (&#x60;,&#x60;). When you specify more than one dispute_state, the response lists disputes that belong to any of the specified dispute_state. (optional)
     * @param  string $update_time_before The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_before must be within the last 180 days and the default is the current time. (optional)
     * @param  string $update_time_after The date and time when the dispute was last updated, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). For example, *&#x60;yyyy&#x60;*-*&#x60;MM&#x60;*-*&#x60;dd&#x60;*&#x60;T&#x60;*&#x60;HH&#x60;*:*&#x60;mm&#x60;*:*&#x60;ss&#x60;*.*&#x60;SSS&#x60;*&#x60;Z&#x60;. update_time_after must be within the last 180 days and the default is the maximum time (180 days) supported. (optional)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listDisputesRequest($start_time = null, $disputed_transaction_id = null, $page_size = null, $next_page_token = null, $dispute_state = null, $update_time_before = null, $update_time_after = null, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null)
    {

        $resourcePath = '/v1/customer/disputes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_time !== null) {
            $queryParams['start_time'] = ObjectSerializer::toQueryValue($start_time);
        }
        // query params
        if ($disputed_transaction_id !== null) {
            $queryParams['disputed_transaction_id'] = ObjectSerializer::toQueryValue($disputed_transaction_id);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['page_size'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token);
        }
        // query params
        if ($dispute_state !== null) {
            $queryParams['dispute_state'] = ObjectSerializer::toQueryValue($dispute_state);
        }
        // query params
        if ($update_time_before !== null) {
            $queryParams['update_time_before'] = ObjectSerializer::toQueryValue($update_time_before);
        }
        // query params
        if ($update_time_after !== null) {
            $queryParams['update_time_after'] = ObjectSerializer::toQueryValue($update_time_after);
        }
        // header params
        if ($pay_pal_request_id !== null) {
            $headerParams['PayPal-Request-Id'] = ObjectSerializer::toHeaderValue($pay_pal_request_id);
        }
        // header params
        if ($pay_pal_client_metadata_id !== null) {
            $headerParams['PayPal-Client-Metadata-Id'] = ObjectSerializer::toHeaderValue($pay_pal_client_metadata_id);
        }
        // header params
        if ($pay_pal_partner_attribution_id !== null) {
            $headerParams['PayPal-Partner-Attribution-Id'] = ObjectSerializer::toHeaderValue($pay_pal_partner_attribution_id);
        }
        // header params
        if ($pay_pal_auth_assertion !== null) {
            $headerParams['PayPal-Auth-Assertion'] = ObjectSerializer::toHeaderValue($pay_pal_auth_assertion);
        }
        // header params
        if ($prefer !== null) {
            $headerParams['Prefer'] = ObjectSerializer::toHeaderValue($prefer);
        }
        // header params
        if ($prefer2 !== null) {
            $headerParams['Prefer'] = ObjectSerializer::toHeaderValue($prefer2);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation makeOfferToResolveDispute
     *
     * Make offer to resolve dispute
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body19 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \PayPal\RestApi\Model\InlineResponse20011
     */
    public function makeOfferToResolveDispute($dispute_id, $body = null)
    {
        list($response) = $this->makeOfferToResolveDisputeWithHttpInfo($dispute_id, $body);
        return $response;
    }

    /**
     * Operation makeOfferToResolveDisputeWithHttpInfo
     *
     * Make offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body19 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \PayPal\RestApi\Model\InlineResponse20011, HTTP status code, HTTP response headers (array of strings)
     */
    public function makeOfferToResolveDisputeWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20011';
        $request = $this->makeOfferToResolveDisputeRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse20011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4039',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40426',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse42215',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation makeOfferToResolveDisputeAsync
     *
     * Make offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body19 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makeOfferToResolveDisputeAsync($dispute_id, $body = null)
    {
        return $this->makeOfferToResolveDisputeAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation makeOfferToResolveDisputeAsyncWithHttpInfo
     *
     * Make offer to resolve dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body19 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makeOfferToResolveDisputeAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20011';
        $request = $this->makeOfferToResolveDisputeRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'makeOfferToResolveDispute'
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body19 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function makeOfferToResolveDisputeRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling makeOfferToResolveDispute'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/make-offer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation partiallyUpdateDispute
     *
     * Partially update dispute
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body12[] $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function partiallyUpdateDispute($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        $this->partiallyUpdateDisputeWithHttpInfo($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);
    }

    /**
     * Operation partiallyUpdateDisputeWithHttpInfo
     *
     * Partially update dispute
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body12[] $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function partiallyUpdateDisputeWithHttpInfo($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        $returnType = '';
        $request = $this->partiallyUpdateDisputeRequest($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4032',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40419',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse42212',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation partiallyUpdateDisputeAsync
     *
     * Partially update dispute
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body12[] $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function partiallyUpdateDisputeAsync($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        return $this->partiallyUpdateDisputeAsyncWithHttpInfo($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation partiallyUpdateDisputeAsyncWithHttpInfo
     *
     * Partially update dispute
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body12[] $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function partiallyUpdateDisputeAsyncWithHttpInfo($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        $returnType = '';
        $request = $this->partiallyUpdateDisputeRequest($dispute_id, $pay_pal_request_id, $pay_pal_client_metadata_id, $pay_pal_partner_attribution_id, $pay_pal_auth_assertion, $prefer, $prefer2, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'partiallyUpdateDispute'
     *
     * @param  string $dispute_id (required)
     * @param  string $pay_pal_request_id The server stores keys for 6 hours. The API callers can request the times to up to 72 hours by speaking to their Account Manager. (optional)
     * @param  string $pay_pal_client_metadata_id Optional. Verifies that the payment originates from a valid, user-consented device and application. Reduces fraud and decreases declines. Transactions that do not include a client metadata ID are not eligible for PayPal Seller Protection. (optional)
     * @param  string $pay_pal_partner_attribution_id Optional. Identifies the caller as a PayPal partner. To receive revenue attribution, specify a unique build notation (BN) code. BN codes provide tracking on all transactions that originate or are associated with a particular partner. To find your BN code, see Code and Credential Reference. (optional)
     * @param  string $pay_pal_auth_assertion An API client-provided JSON Web Token (JWT) assertion that identifies the merchant. To use this header, you must get consent to act on behalf of a merchant. (optional)
     * @param  string $prefer The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  string $prefer2 The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt; (optional)
     * @param  \PayPal\RestApi\Model\Body12[] $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function partiallyUpdateDisputeRequest($dispute_id, $pay_pal_request_id = null, $pay_pal_client_metadata_id = null, $pay_pal_partner_attribution_id = null, $pay_pal_auth_assertion = null, $prefer = null, $prefer2 = null, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling partiallyUpdateDispute'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($pay_pal_request_id !== null) {
            $headerParams['PayPal-Request-Id'] = ObjectSerializer::toHeaderValue($pay_pal_request_id);
        }
        // header params
        if ($pay_pal_client_metadata_id !== null) {
            $headerParams['PayPal-Client-Metadata-Id'] = ObjectSerializer::toHeaderValue($pay_pal_client_metadata_id);
        }
        // header params
        if ($pay_pal_partner_attribution_id !== null) {
            $headerParams['PayPal-Partner-Attribution-Id'] = ObjectSerializer::toHeaderValue($pay_pal_partner_attribution_id);
        }
        // header params
        if ($pay_pal_auth_assertion !== null) {
            $headerParams['PayPal-Auth-Assertion'] = ObjectSerializer::toHeaderValue($pay_pal_auth_assertion);
        }
        // header params
        if ($prefer !== null) {
            $headerParams['Prefer'] = ObjectSerializer::toHeaderValue($prefer);
        }
        // header params
        if ($prefer2 !== null) {
            $headerParams['Prefer'] = ObjectSerializer::toHeaderValue($prefer2);
        }

        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation provideEvidence
     *
     * Provide evidence
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  string $evidence_file A file with evidence. (optional)
     * @param  string $input input (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \PayPal\RestApi\Model\InlineResponse20010
     */
    public function provideEvidence($dispute_id, $evidence_file = null, $input = null)
    {
        list($response) = $this->provideEvidenceWithHttpInfo($dispute_id, $evidence_file, $input);
        return $response;
    }

    /**
     * Operation provideEvidenceWithHttpInfo
     *
     * Provide evidence
     *
     * @param  string $dispute_id (required)
     * @param  string $evidence_file A file with evidence. (optional)
     * @param  string $input (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \PayPal\RestApi\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function provideEvidenceWithHttpInfo($dispute_id, $evidence_file = null, $input = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20010';
        $request = $this->provideEvidenceRequest($dispute_id, $evidence_file, $input);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4009',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation provideEvidenceAsync
     *
     * Provide evidence
     *
     * @param  string $dispute_id (required)
     * @param  string $evidence_file A file with evidence. (optional)
     * @param  string $input (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provideEvidenceAsync($dispute_id, $evidence_file = null, $input = null)
    {
        return $this->provideEvidenceAsyncWithHttpInfo($dispute_id, $evidence_file, $input)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation provideEvidenceAsyncWithHttpInfo
     *
     * Provide evidence
     *
     * @param  string $dispute_id (required)
     * @param  string $evidence_file A file with evidence. (optional)
     * @param  string $input (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provideEvidenceAsyncWithHttpInfo($dispute_id, $evidence_file = null, $input = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20010';
        $request = $this->provideEvidenceRequest($dispute_id, $evidence_file, $input);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'provideEvidence'
     *
     * @param  string $dispute_id (required)
     * @param  string $evidence_file A file with evidence. (optional)
     * @param  string $input (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function provideEvidenceRequest($dispute_id, $evidence_file = null, $input = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling provideEvidence'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/provide-evidence';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // form params
        if ($evidence_file !== null) {
            $formParams['evidence-file'] = ObjectSerializer::toFormValue($evidence_file);
        }
        // form params
        if ($input !== null) {
            $formParams['input'] = ObjectSerializer::toFormValue($input);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation provideSupportingInformationForDispute
     *
     * Provide supporting information for dispute
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  string $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \PayPal\RestApi\Model\InlineResponse20010
     */
    public function provideSupportingInformationForDispute($dispute_id, $body = null)
    {
        list($response) = $this->provideSupportingInformationForDisputeWithHttpInfo($dispute_id, $body);
        return $response;
    }

    /**
     * Operation provideSupportingInformationForDisputeWithHttpInfo
     *
     * Provide supporting information for dispute
     *
     * @param  string $dispute_id (required)
     * @param  string $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \PayPal\RestApi\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function provideSupportingInformationForDisputeWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20010';
        $request = $this->provideSupportingInformationForDisputeRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation provideSupportingInformationForDisputeAsync
     *
     * Provide supporting information for dispute
     *
     * @param  string $dispute_id (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provideSupportingInformationForDisputeAsync($dispute_id, $body = null)
    {
        return $this->provideSupportingInformationForDisputeAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation provideSupportingInformationForDisputeAsyncWithHttpInfo
     *
     * Provide supporting information for dispute
     *
     * @param  string $dispute_id (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provideSupportingInformationForDisputeAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20010';
        $request = $this->provideSupportingInformationForDisputeRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'provideSupportingInformationForDispute'
     *
     * @param  string $dispute_id (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function provideSupportingInformationForDisputeRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling provideSupportingInformationForDispute'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/provide-supporting-info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendMessageAboutDisputeToOtherParty
     *
     * Send message about dispute to other party
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body21 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \PayPal\RestApi\Model\InlineResponse20010
     */
    public function sendMessageAboutDisputeToOtherParty($dispute_id, $body = null)
    {
        list($response) = $this->sendMessageAboutDisputeToOtherPartyWithHttpInfo($dispute_id, $body);
        return $response;
    }

    /**
     * Operation sendMessageAboutDisputeToOtherPartyWithHttpInfo
     *
     * Send message about dispute to other party
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body21 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \PayPal\RestApi\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendMessageAboutDisputeToOtherPartyWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20010';
        $request = $this->sendMessageAboutDisputeToOtherPartyRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40311',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40428',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse42216',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendMessageAboutDisputeToOtherPartyAsync
     *
     * Send message about dispute to other party
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body21 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendMessageAboutDisputeToOtherPartyAsync($dispute_id, $body = null)
    {
        return $this->sendMessageAboutDisputeToOtherPartyAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendMessageAboutDisputeToOtherPartyAsyncWithHttpInfo
     *
     * Send message about dispute to other party
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body21 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendMessageAboutDisputeToOtherPartyAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse20010';
        $request = $this->sendMessageAboutDisputeToOtherPartyRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendMessageAboutDisputeToOtherParty'
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body21 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendMessageAboutDisputeToOtherPartyRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling sendMessageAboutDisputeToOtherParty'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/send-message';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation settleDispute
     *
     * Settle dispute
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body16 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function settleDispute($dispute_id, $body = null)
    {
        $this->settleDisputeWithHttpInfo($dispute_id, $body);
    }

    /**
     * Operation settleDisputeWithHttpInfo
     *
     * Settle dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body16 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function settleDisputeWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->settleDisputeRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40423',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation settleDisputeAsync
     *
     * Settle dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body16 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settleDisputeAsync($dispute_id, $body = null)
    {
        return $this->settleDisputeAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation settleDisputeAsyncWithHttpInfo
     *
     * Settle dispute
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body16 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settleDisputeAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->settleDisputeRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'settleDispute'
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body16 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function settleDisputeRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling settleDispute'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/adjudicate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showDisputeDetails
     *
     * Show dispute details
     *
     * @param  string $dispute_id dispute_id (required)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \PayPal\RestApi\Model\InlineResponse2008
     */
    public function showDisputeDetails($dispute_id)
    {
        list($response) = $this->showDisputeDetailsWithHttpInfo($dispute_id);
        return $response;
    }

    /**
     * Operation showDisputeDetailsWithHttpInfo
     *
     * Show dispute details
     *
     * @param  string $dispute_id (required)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \PayPal\RestApi\Model\InlineResponse2008, HTTP status code, HTTP response headers (array of strings)
     */
    public function showDisputeDetailsWithHttpInfo($dispute_id)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse2008';
        $request = $this->showDisputeDetailsRequest($dispute_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse2008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse4031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40418',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showDisputeDetailsAsync
     *
     * Show dispute details
     *
     * @param  string $dispute_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showDisputeDetailsAsync($dispute_id)
    {
        return $this->showDisputeDetailsAsyncWithHttpInfo($dispute_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showDisputeDetailsAsyncWithHttpInfo
     *
     * Show dispute details
     *
     * @param  string $dispute_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showDisputeDetailsAsyncWithHttpInfo($dispute_id)
    {
        $returnType = '\PayPal\RestApi\Model\InlineResponse2008';
        $request = $this->showDisputeDetailsRequest($dispute_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showDisputeDetails'
     *
     * @param  string $dispute_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function showDisputeDetailsRequest($dispute_id)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling showDisputeDetails'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDisputeStatus
     *
     * Update dispute status
     *
     * @param  string $dispute_id dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body20 $body body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateDisputeStatus($dispute_id, $body = null)
    {
        $this->updateDisputeStatusWithHttpInfo($dispute_id, $body);
    }

    /**
     * Operation updateDisputeStatusWithHttpInfo
     *
     * Update dispute status
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body20 $body (optional)
     *
     * @throws \PayPal\RestApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDisputeStatusWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->updateDisputeStatusRequest($dispute_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40310',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPal\RestApi\Model\InlineResponse40427',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDisputeStatusAsync
     *
     * Update dispute status
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body20 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDisputeStatusAsync($dispute_id, $body = null)
    {
        return $this->updateDisputeStatusAsyncWithHttpInfo($dispute_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDisputeStatusAsyncWithHttpInfo
     *
     * Update dispute status
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body20 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDisputeStatusAsyncWithHttpInfo($dispute_id, $body = null)
    {
        $returnType = '';
        $request = $this->updateDisputeStatusRequest($dispute_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDisputeStatus'
     *
     * @param  string $dispute_id (required)
     * @param  \PayPal\RestApi\Model\Body20 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDisputeStatusRequest($dispute_id, $body = null)
    {
        // verify the required parameter 'dispute_id' is set
        if ($dispute_id === null || (is_array($dispute_id) && count($dispute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dispute_id when calling updateDisputeStatus'
            );
        }

        $resourcePath = '/v1/customer/disputes/{dispute_id}/require-evidence';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dispute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dispute_id' . '}',
                ObjectSerializer::toPathValue($dispute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
